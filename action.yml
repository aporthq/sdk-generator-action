name: "APort SDK Generator"
description: "Generate SDKs and client libraries for APort agents"
author: "APort Team"
branding:
  icon: "code"
  color: "purple"

inputs:
  agent-id:
    description: "The APort Agent ID to generate SDK for."
    required: true
  api-base:
    description: "The base URL for the APort API."
    required: false
    default: "https://api.aport.io"
  output-dir:
    description: "Directory to output generated SDK files."
    required: false
    default: "./generated-sdk"
  languages:
    description: "Comma-separated list of languages to generate (e.g., 'python,nodejs,go')."
    required: false
    default: "python,nodejs"
  include-types:
    description: "Whether to include TypeScript type definitions."
    required: false
    default: "true"
  github-token:
    description: "GitHub token for publishing generated SDKs."
    required: false
    default: ${{ github.token }}

outputs:
  generated_files:
    description: "JSON array of generated file paths."
    value: ${{ steps.sdk-generator.outputs.generated_files }}
  languages_generated:
    description: "JSON array of languages that were successfully generated."
    value: ${{ steps.sdk-generator.outputs.languages_generated }}
  success:
    description: "Boolean indicating if SDK generation was successful."
    value: ${{ steps.sdk-generator.outputs.success }}

runs:
  using: "composite"
  steps:
    - name: Generate SDK
      id: sdk-generator
      env:
        APORT_API_BASE: ${{ inputs.api-base }}
        APORT_AGENT_ID: ${{ inputs.agent-id }}
        OUTPUT_DIR: ${{ inputs.output-dir }}
        LANGUAGES: ${{ inputs.languages }}
        INCLUDE_TYPES: ${{ inputs.include-types }}
      run: |
        echo "ðŸ”§ Generating SDK for agent: $APORT_AGENT_ID"
        echo "Languages: $LANGUAGES"
        echo "Output directory: $OUTPUT_DIR"
        
        # Create output directory
        mkdir -p "$OUTPUT_DIR"
        
        # Get agent passport to understand capabilities
        echo "ðŸ“¥ Fetching agent passport..."
        RESPONSE=$(curl -s -X GET "$APORT_API_BASE/api/verify/$APORT_AGENT_ID")
        
        if [ $? -ne 0 ]; then
          echo "âŒ Failed to fetch agent passport"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Parse agent capabilities
        CAPABILITIES=$(echo "$RESPONSE" | jq -r '.capabilities // []')
        ASSURANCE_LEVEL=$(echo "$RESPONSE" | jq -r '.assurance_level // 0')
        AGENT_NAME=$(echo "$RESPONSE" | jq -r '.name // "Unknown Agent"')
        
        echo "ðŸ“Š Agent: $AGENT_NAME (Assurance Level: $ASSURANCE_LEVEL)"
        echo "ðŸ”§ Capabilities: $CAPABILITIES"
        
        # Generate SDK for each language
        IFS=',' read -ra LANG_ARRAY <<< "$LANGUAGES"
        GENERATED_FILES="[]"
        GENERATED_LANGS="[]"
        
        for lang in "${LANG_ARRAY[@]}"; do
          lang=$(echo "$lang" | xargs) # trim whitespace
          echo "ðŸš€ Generating $lang SDK..."
          
          case "$lang" in
            "python")
              mkdir -p "$OUTPUT_DIR/python"
              # Generate Python SDK
              cat > "$OUTPUT_DIR/python/__init__.py" << EOF
"""
APort SDK for $AGENT_NAME
Generated automatically by APort SDK Generator
"""

__version__ = "1.0.0"
__agent_id__ = "$APORT_AGENT_ID"
__assurance_level__ = $ASSURANCE_LEVEL

from .client import APortClient
from .types import AgentPassport, PolicyContext

__all__ = ["APortClient", "AgentPassport", "PolicyContext"]
EOF
              
              cat > "$OUTPUT_DIR/python/client.py" << EOF
"""APort Client for $AGENT_NAME"""

import requests
from typing import Dict, Any, Optional
from .types import AgentPassport, PolicyContext

class APortClient:
    def __init__(self, api_base: str = "$APORT_API_BASE"):
        self.api_base = api_base.rstrip('/')
        self.agent_id = "$APORT_AGENT_ID"
    
    def get_passport(self) -> AgentPassport:
        """Get the agent passport"""
        response = requests.get(f"{self.api_base}/api/verify/{self.agent_id}")
        response.raise_for_status()
        return AgentPassport(**response.json())
    
    def verify_policy(self, context: PolicyContext) -> Dict[str, Any]:
        """Verify policy against agent"""
        response = requests.post(
            f"{self.api_base}/api/verify/policy/code.repository.merge.v1",
            json={"agent_id": self.agent_id, "context": context.dict()}
        )
        response.raise_for_status()
        return response.json()
EOF
              
              cat > "$OUTPUT_DIR/python/types.py" << EOF
"""Type definitions for APort SDK"""

from typing import Dict, Any, Optional, List
from dataclasses import dataclass

@dataclass
class PolicyContext:
    repo: str
    base_branch: str
    github_actor: Optional[str] = None
    github_app: Optional[str] = None
    files_changed: int = 0
    lines_added: int = 0
    labels: List[str] = None
    reviews: int = 0
    is_draft: bool = False
    is_mergeable: bool = True

@dataclass
class AgentPassport:
    agent_id: str
    name: str
    assurance_level: int
    assurance_method: str
    capabilities: List[str]
    # Add other fields as needed
EOF
              
              cat > "$OUTPUT_DIR/python/requirements.txt" << EOF
requests>=2.28.0
pydantic>=1.10.0
EOF
              
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/python/__init__.py" '. + [$file]')
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/python/client.py" '. + [$file]')
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/python/types.py" '. + [$file]')
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/python/requirements.txt" '. + [$file]')
              GENERATED_LANGS=$(echo "$GENERATED_LANGS" | jq --arg lang "python" '. + [$lang]')
              ;;
              
            "nodejs")
              mkdir -p "$OUTPUT_DIR/nodejs"
              # Generate Node.js SDK
              cat > "$OUTPUT_DIR/nodejs/package.json" << EOF
{
  "name": "@aport/sdk-$APORT_AGENT_ID",
  "version": "1.0.0",
  "description": "APort SDK for $AGENT_NAME",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "axios": "^1.3.0"
  },
  "devDependencies": {
    "@types/node": "^18.0.0",
    "typescript": "^4.9.0",
    "jest": "^29.0.0"
  }
}
EOF
              
              cat > "$OUTPUT_DIR/nodejs/src/index.ts" << EOF
/**
 * APort SDK for $AGENT_NAME
 * Generated automatically by APort SDK Generator
 */

export interface PolicyContext {
  repo: string;
  base_branch: string;
  github_actor?: string;
  github_app?: string;
  files_changed: number;
  lines_added: number;
  labels: string[];
  reviews: number;
  is_draft: boolean;
  is_mergeable: boolean;
}

export interface AgentPassport {
  agent_id: string;
  name: string;
  assurance_level: number;
  assurance_method: string;
  capabilities: string[];
}

export class APortClient {
  private apiBase: string;
  private agentId: string;

  constructor(apiBase: string = "$APORT_API_BASE") {
    this.apiBase = apiBase.replace(/\/$/, '');
    this.agentId = "$APORT_AGENT_ID";
  }

  async getPassport(): Promise<AgentPassport> {
    const response = await fetch(\`\${this.apiBase}/api/verify/\${this.agentId}\`);
    if (!response.ok) {
      throw new Error(\`Failed to fetch passport: \${response.statusText}\`);
    }
    return response.json();
  }

  async verifyPolicy(context: PolicyContext): Promise<any> {
    const response = await fetch(\`\${this.apiBase}/api/verify/policy/code.repository.merge.v1\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        agent_id: this.agentId,
        context
      })
    });
    
    if (!response.ok) {
      throw new Error(\`Policy verification failed: \${response.statusText}\`);
    }
    
    return response.json();
  }
}
EOF
              
              cat > "$OUTPUT_DIR/nodejs/tsconfig.json" << EOF
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
EOF
              
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/nodejs/package.json" '. + [$file]')
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/nodejs/src/index.ts" '. + [$file]')
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/nodejs/tsconfig.json" '. + [$file]')
              GENERATED_LANGS=$(echo "$GENERATED_LANGS" | jq --arg lang "nodejs" '. + [$lang]')
              ;;
              
            "go")
              mkdir -p "$OUTPUT_DIR/go"
              # Generate Go SDK
              cat > "$OUTPUT_DIR/go/go.mod" << EOF
module github.com/aport/sdk-$APORT_AGENT_ID

go 1.19

require (
    github.com/stretchr/testify v1.8.2
)
EOF
              
              cat > "$OUTPUT_DIR/go/client.go" << EOF
package aport

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
)

// PolicyContext represents the context for policy verification
type PolicyContext struct {
    Repo         string   \`json:"repo"\`
    BaseBranch   string   \`json:"base_branch"\`
    GitHubActor  *string  \`json:"github_actor,omitempty"\`
    GitHubApp    *string  \`json:"github_app,omitempty"\`
    FilesChanged int      \`json:"files_changed"\`
    LinesAdded   int      \`json:"lines_added"\`
    Labels       []string \`json:"labels"\`
    Reviews      int      \`json:"reviews"\`
    IsDraft      bool     \`json:"is_draft"\`
    IsMergeable  bool     \`json:"is_mergeable"\`
}

// AgentPassport represents the agent passport
type AgentPassport struct {
    AgentID         string   \`json:"agent_id"\`
    Name            string   \`json:"name"\`
    AssuranceLevel  int      \`json:"assurance_level"\`
    AssuranceMethod string   \`json:"assurance_method"\`
    Capabilities    []string \`json:"capabilities"\`
}

// APortClient is the main client for interacting with APort
type APortClient struct {
    apiBase  string
    agentID  string
    client   *http.Client
}

// NewClient creates a new APort client
func NewClient(apiBase string) *APortClient {
    if apiBase == "" {
        apiBase = "$APORT_API_BASE"
    }
    return &APortClient{
        apiBase: apiBase,
        agentID: "$APORT_AGENT_ID",
        client:  &http.Client{},
    }
}

// GetPassport retrieves the agent passport
func (c *APortClient) GetPassport() (*AgentPassport, error) {
    url := fmt.Sprintf("%s/api/verify/%s", c.apiBase, c.agentID)
    resp, err := c.client.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("failed to fetch passport: %s", resp.Status)
    }

    var passport AgentPassport
    if err := json.NewDecoder(resp.Body).Decode(&passport); err != nil
        return nil, err
    }

    return &passport, nil
}

// VerifyPolicy verifies policy against the agent
func (c *APortClient) VerifyPolicy(ctx PolicyContext) (map[string]interface{}, error) {
    url := fmt.Sprintf("%s/api/verify/policy/code.repository.merge.v1", c.apiBase)
    
    payload := map[string]interface{}{
        "agent_id": c.agentID,
        "context":  ctx,
    }

    jsonData, err := json.Marshal(payload)
    if err != nil {
        return nil, err
    }

    resp, err := c.client.Post(url, "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("policy verification failed: %s", resp.Status)
    }

    var result map[string]interface{}
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return result, nil
}
EOF
              
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/go/go.mod" '. + [$file]')
              GENERATED_FILES=$(echo "$GENERATED_FILES" | jq --arg file "$OUTPUT_DIR/go/client.go" '. + [$file]')
              GENERATED_LANGS=$(echo "$GENERATED_LANGS" | jq --arg lang "go" '. + [$lang]')
              ;;
              
            *)
              echo "âš ï¸ Unsupported language: $lang"
              ;;
          esac
        done
        
        echo "generated_files=$GENERATED_FILES" >> $GITHUB_OUTPUT
        echo "languages_generated=$GENERATED_LANGS" >> $GITHUB_OUTPUT
        echo "success=true" >> $GITHUB_OUTPUT
        
        echo "âœ… SDK generation completed successfully"
      shell: bash

    - name: Report results
      run: |
        echo "ðŸ“Š SDK Generation Results:"
        echo "  Agent ID: ${{ inputs.agent-id }}"
        echo "  Languages: ${{ steps.sdk-generator.outputs.languages_generated }}"
        echo "  Files Generated: ${{ steps.sdk-generator.outputs.generated_files }}"
        echo "  Success: ${{ steps.sdk-generator.outputs.success }}"
